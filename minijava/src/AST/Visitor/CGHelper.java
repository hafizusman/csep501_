package AST.Visitor;

import sun.reflect.generics.reflectiveObjects.NotImplementedException;

import java.io.FileWriter;

/**
 * Created by Muhammad on 6/7/2014.
 */
public class CGHelper {
    private static final String m_fileName = "blah.asm";
    private static FileWriter f = null;
    private static boolean init = false;

    public void initWriter()
    {
        try {
            f = new FileWriter(m_fileName);
            init = true;
        }
        catch(Exception e)
        {
            System.out.println("ERROR: failed to create file: " + m_fileName.toString());
        }

    }

    public void gen(String s)
    {
        System.out.print(s);
        if (init) {
            try {
                f.write(s);
                f.flush();
            }
            catch (Exception e) {
                System.out.println("ERROR: failed to write file: " + m_fileName.toString());
            }
        }
    }
    private void genTitle(String s)
    {
        gen("TITLE\t" + s.toString());
        gen("\n");
    }

    public void genCommentLine(String s)
    {
        gen("; " + s.toString());
        gen("\n");
    }

    public void genAsmPreamble()
    {
        genCommentLine("Listing generated by MuhammadUsman Non-optimizing Compiler Version <>");
        gen("\n");
        genTitle(m_fileName);
        gen("\n");
        gen(
            "\t.686P \n" +
            "\t.XMM  \n" +
            "\tinclude listing.inc \n" +
            "\t.model	flat \n" +
            "\n" +
            "INCLUDELIB LIBCMT \n" +
            "INCLUDELIB OLDNAMES \n" +
            "\n" +
            "PUBLIC	_asm_main \n" +
            "EXTRN	_put:PROC \n" +
            "EXTRN	_get:PROC \n" +
            "EXTRN  _mjmalloc:PROC \n" +
            "\n" +
            "_TEXT	SEGMENT \n" +
            "_argc$ = 8                       ; size = 4 \n" +
            "_argv$ = 12                      ; size = 4 \n" +
            "\n"
        );
    }

    public void genCallerProlog(int [] Args, String funcName)
    {
        //
        // push args right to left (decrement stack)
        // call (note that the hardware will push the return address (i.e. eip) into the stack then do the jump for u)
        //
        for (int i = Args.length; i > 0; i--) {
            gen("push\t" + Integer.toString(Args[i-1]));
            gen("\n");
        }
        gen("call\t"+funcName.toString());
        gen("\n");
    }
    public void genCallerEpilog(int cbArgs)
    {
        //
        // pop args (simply increment stack by total number of args size)
        // return value (if any) will be in eax. store if needed from eax to memory[ebp+offset-n]
        //
        if (cbArgs > 0) {
            gen("add\t\tesp, " + Integer.toString(cbArgs));
            gen("\n");
        }
    }

    public void genCalleeProlog(int cbTotalLocals)
    {
        gen("push\tebp");
        gen("\n");
        gen("mov\t\tebp, esp");
        gen("\n");
        if (cbTotalLocals != 0) {
            gen("sub\t\tesp, " + Integer.toString(cbTotalLocals));
            gen("\n");
        }
    }

    public void genCalleeEpilog()
    {
        gen("mov\t\tesp, ebp");
        gen("\n");
        gen("pop\t\tebp");
        gen("\n");
        gen("ret");
        gen("\n");
    }

    public void genAsmPostamble()
    {
        gen(
            "_TEXT	ENDS \n" +
            "END \n"
        );
    }
}
