/*
/*
 * CUP specification for the parser for a simple demo language.
 * Change this into the parser for your implementation of MiniJava.
 * CSE 401/P501 Au11.
 */

package Parser;

import AST.*;
import java.util.*;
import java_cup.runtime.*;

/* Code in the following section is included in the generated parser */

parser code {:
  /* Override default error message routine to handle line numbers correctly */
  /* This routine is also called in the process of handling fatal errors. */

  /** Report a non fatal error (or warning).  This method takes a message 
   *  string and an additional object (to be used by specializations 
   *  implemented in subclasses).  Prints the same simple error message
   *  as the base class version, but correctly labels the line number.
   *
   * @param message an error message.
   * @param info    an extra object reserved for use by specialized subclasses.
   */
  public void report_error(String message, Object info)
    {
      System.err.print(message);
      System.err.flush();
      if (info instanceof Symbol)
	if (((Symbol)info).left != -1)
	  System.err.println(" at line " + ((Symbol)info).left +
			     " of input");
	else System.err.println("");
      else System.err.println("");
    }
:};  

/* end of code included in generated parser


/* Terminals (tokens returned by the scanner) */

/* reserved words: */
terminal DISPLAY, CLASS, PUBLIC, STATIC, VOID, NEW, RETURN, THIS, IF, ELSE, TRUE, FALSE, WHILE, EXTENDS, MAIN, LENGTH;

/* operators: */
terminal MULTIPLY, PLUS, MINUS, LESSTHAN, LOGICAL_AND, LOGICAL_NOT, BECOMES;

/* delimiters: */
terminal LPAREN, RPAREN, LBRACKET, RBRACKET, LCURLY, RCURLY, SEMICOLON, DOT, COMMA;

/* basic types */
terminal INTEGER_TYPE, BOOLEAN_TYPE, STRING_TYPE;

/* tokens with values: */
terminal String IDENTIFIER;
terminal String INTEGER_LITERAL;


/* Nonterminals */

nonterminal List<Statement> Program;
nonterminal Statement Statement;
nonterminal Block Block;
nonterminal BlockStatements;
nonterminal Exp Expression;
nonterminal ExpList ExpressionList;
nonterminal Exp ExpressionListNext;
nonterminal Identifier Identifier;


/* Precedence declarations */

precedence nonassoc LESSTHAN;
precedence nonassoc LOGICAL_AND;
precedence nonassoc LOGICAL_NOT;
precedence left PLUS;
precedence left MINUS;
precedence left MULTIPLY;


/* Productions */

Program             ::= Statement:s
                        {: List<Statement> p = new LinkedList<Statement>();
                            p.add(s);
                            RESULT = p; :}
                    | Program:p Statement:s
                        {: p.add(s); RESULT = p; :}
                    ;


//Identifier	    ::=	<IDENTIFIER>
Identifier          ::= IDENTIFIER:id
                        {: RESULT = new Identifier(id, idleft); :}
                    ;

// Statement	::=	"{" ( Statement )* "}"
//      |	"if" "(" Expression ")" Statement "else" Statement
//      |	"while" "(" Expression ")" Statement
//      |	"System.out.println" "(" Expression ")" ";"
//      |	Identifier "=" Expression ";"
//      |	Identifier "[" Expression "]" "=" Expression ";"
Statement           ::= Block:b
                        {}
                    | IF LPAREN Expression:ifexpr RPAREN Statement:thenstmt ELSE Statement:elsestmt
                        {: RESULT = new If(ifexpr, thenstmt, elsestmt, ifexprleft); :}
                    | WHILE LPAREN Expression:expr RPAREN Statement:stmt
                        {: RESULT = new While(expr, stmt, exprleft); :}
                    | DISPLAY:d LPAREN Expression:expr RPAREN SEMICOLON
                        {: RESULT = new Display(expr, dleft); :}
                    | Identifier:name BECOMES Expression:expr SEMICOLON
                        {: RESULT = new Assign(name, expr, nameleft); :}
                    | Identifier:name LBRACKET Expression:expr1 RBRACKET BECOMES Expression:expr2 SEMICOLON
                        {: RESULT = new ArrayAssign(name, expr1, expr2, nameleft); :}
                    ;
Block               ::= LCURLY BlockStatements RCURLY
                    ;

BlockStatements     ::= /* empty */
                    | Statement:s BlockStatements:b
                    ;

// Expression	::=	Expression ( "&&" | "<" | "+" | "-" | "*" ) Expression
//      |	Expression "[" Expression "]"
//      |	Expression "." "length"
//      |	Expression "." Identifier "(" ( Expression ( "," Expression )* )? ")"
//      |	<INTEGER_LITERAL>
//      |	"true"
//      |	"false"
//      |	Identifier
//      |	"this"
//      |	"new" "int" "[" Expression "]"
//      |	"new" Identifier "(" ")"
//      |	"!" Expression
//      |	"(" Expression ")"
Expression          ::= Expression:arg1 LOGICAL_AND Expression:arg2
                        {: RESULT = new And(arg1, arg2, arg1left); :}
                    | Expression:arg1 LESSTHAN Expression:arg2
                        {: RESULT = new LessThan(arg1, arg2, arg1left); :}
                    | Expression:arg1 PLUS Expression:arg2
                        {: RESULT = new Plus(arg1, arg2, arg1left); :}
                    | Expression:arg1 MINUS Expression:arg2
                        {: RESULT = new Minus(arg1, arg2, arg1left); :}
                    | Expression:arg1 MULTIPLY Expression:arg2
                        {: RESULT = new Times(arg1, arg2, arg1left); :}
                    | Expression:arg1 LBRACKET Expression:arg2 RBRACKET
                        {: RESULT = new ArrayLookup(arg1, arg2, arg1left); :}
                    | Expression:arg1 DOT LENGTH
                        {: RESULT = new ArrayLength(arg1, arg1left); :}
                    | Expression:expr DOT Identifier:name LPAREN ExpressionList:exprlist RPAREN
                        {: RESULT = new Call(expr, name, exprlist, exprleft); :}
                    | INTEGER_LITERAL:val
                        {: RESULT = new IntegerLiteral(Integer.parseInt(val), valleft); :}
                    | TRUE:ln
                        {: RESULT = new True(lnleft); :}
                    | FALSE:ln
                        {: RESULT = new False(lnleft); :}
                    | IDENTIFIER:name
                        {: RESULT = new IdentifierExp(name, nameleft); :}
                    | THIS:ln
                        {: RESULT = new This(lnleft); :}
                    | NEW INTEGER_TYPE LBRACKET Expression:expr RBRACKET
                        {: RESULT = new NewArray(expr, exprleft); :} /* CHECK!!!! */
                    | NEW Identifier:name LPAREN RPAREN
                        {: RESULT = new NewObject(name, nameleft); :} /* CHECK!!!! */
                    | LOGICAL_NOT Expression:arg1
                        {: RESULT = new Not(arg1, arg1left); :}
                    | LPAREN Expression:expr RPAREN
                        {: RESULT = expr; :} /* CHECK!!!! */
                    ;

//      |	Expression "." Identifier "(" ( Expression ( "," Expression )* )? ")"
ExpressionList      ::= /* empty */
                    | Expression:expr ExpressionListNext
                        {: RESULT = new ExpList(exprleft); :} /* CHECK!!!! Need to append to list*/
                    ;
ExpressionListNext  ::= /* empty */
                    | COMMA Expression:expr ExpressionListNext:exprn
//                        {: RESULT = new Exp(expr, exprleft); :} /* CHECK!!!! Need to append to list*/
                    ;
